---
title: Cでhello, world(詳細解説)
description: ""
date: 2025-01-30T13:23:22.304644635+09:00
categories:
    - 技術系
draft: true
publish: true
---

切腹倶楽部の[Cでhello, world](https://seppuku.club/memo/c-hello-world/)をようやくしっかりと読んだ。

## ソースコード

無断てんのりをば。怒られたら消す。

```c
print(s,d) void*s,*d; {
  __asm__(".quad 0xcfff48aef2fcffb1" : "=D"(d) : "D"(s), "a"(0));
  __asm__("syscall" :: "a"(1), "D"(1), "S"(s), "d"(d-s));
}

main() {
  print("hello, world\n");
  return 0;
}
```

### 解説

(原文ママ)

```asm
  mov   $0xff,%cl
  cld
  repne scasb
  dec   %rdi
```

## とっかかり

このコードを見たとき、最初は何もわからなかった。解説が何をしているのかもわからなかった。そもそもC言語で`:`が使われている記法なんて知らないので本当に何もわからなかった。

更に言えばK&R的な昔懐かしいような関数定義も、軽く存在を知っていただけで書いたことはなく、どうして引数に`d`があるにも関わらず引数は文字列のみなのか？という疑問から始まった。

## 詳細な解説

### 現代語に書き下す

```c
void print(void* s){
  void* d;
  __asm__(".quad 0xcfff48aef2fcffb1" : "=D"(d) : "D"(s), "a"(0));
  __asm__("syscall" :: "a"(1), "D"(1), "S"(s), "d"(d-s));
}

int main() {
  print("hello, world\n");
  return 0;
}
```

K&Rの表記では引数は必須ではないらしく、原文では単なる`d`の初期化のためだけに引数として書かれているらしい(?)

後述するとこの`d`は文字列の終端文字のアドレスを指しているのが、引数で渡したとしても結局上書きされてしまうので引数として定義する意味はよくわからなかった。

### `void*`ポインタ

私も知ったのは最近のことだが、`void`型のポインタというのは任意の型を取りうるポインタである。

[Additional C features](https://www.arch.info.mie-u.ac.jp/~ohno/lecture/intprog/cmisc.html)

`malloc`等の返り型にもなっており、実質的にCの`any`である。

### GCCインラインアセンブリ記法

世の常だが記号というのはGooglabilityが非常に低い。どうにかたどり着いたのが「GCC インラインアセンブリ」という構文であった。

上記のサイトでは`asm volatile()`という記法が紹介されており、`__asm__`についても言及されている。(残念ながら上記サイトの参考文献はリンク切れしているのだが)

この記法について要約すると以下の通りになる。

```c
void* output;
void* input1, input2;
__asm__(
    "hoge" // ここにアセンブリを書く
    : "=r"(output) // 最終的な出力となるレジスタ
    : "r"(input1), "r"(input2) // 入力として使うレジスタ
)
```

`:`ではレジスタとCの変数を結びつけ(Vueの`v-bind`的な)ている。正確には、コンパイラに使用するレジスタを教えてあげることで安全に利用できるようにするらしい。

指定形式は`"レジスタの種類"(C変数)`で行い、レジスタの種類は以下に規定されている。この種類についての情報が日本語ではほぼ存在しておらず苦しかった。

[GCCインラインアセンブラの使い方 \- bamboo’s blog](https://bamboo-cpu.hatenablog.com/entry/2020/12/03/215111)

こちらのサイトでは日本語で説明を行っているが、この一覧は完全なものではない。現に山Dが利用している`D`については書かれていない。

[GCC\-Inline\-Assembly\-HOWTO](https://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#ss6.1)

完全な一覧はこちらにかかれている。以下にその表を転載する。(怒られポイント+1)

| 記号 | レジスタ         |
| ---- | ---------------- |
| a    | RAX, EAX, AX, AL |
| b    | RBX, EBX, BX, BL |
| c    | RCX, ECX, CX, CL |
| d    | RDX, EDX, DX, DL |
| S    | RSI, ESI, SI     |
| D    | RDI,EDI, DI      |

更に、私はアセンブリ初心者なので`RAX`,`EAX`,`AX`, `AL`の違いがわからなかったがこれらはサイズの違いだけで同じ用途として利用されていることがわかった。([Wikipedia参照](https://ja.wikibooks.org/wiki/X86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%A9/x86%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3))

`RAX`は64bit、`EAX`は32bit、`AX`は16bit、`AL`は8bitであるらしい。

[GCC Inline Assembler](https://www.hazymoon.jp/OpenBSD/annex/gcc_inline_asm.html)

こちらのサイトにかかれている通り、`asm`と`__asm__`は基本的には同一である。しかしANCIなC言語で書いている場合`asm`は予約後になっているらしく、`__asm__`を使用する必要がある。

### quadについて

インライン記法については理解できたものの、相変わらず`quad`はわからない。これは64bitの数値を定義するものなので、最初はなにかの外部ライブラリのメモリアドレスを定義しているのだと思った。

しかしこのアドレスで検索しても出てくるのは切腹倶楽部のみという、非常に絶望的な状態であったため何かアドレスではない独自の意味合いなのではないかと考え始めた。

![Google先生の絶望的な回答](google-addr.png)

山D先生に質問してみるものの、返答は「ちゃんと解説書いてるよ(鼻ほじ)」「いつからqword幅の16進数がアドレスだと勘違いしていた!」という感動的なスパルタ方式だったため諦めて調査を続行。

以前にMWS CupというCTFに参加するために勉強したGhidraでコンパイルされたバイナリを解析することで何かヒントが得られないかと、何気なく検索をかけたところビンゴ!

![Ghidra先生の有り難いお言葉](ghidra.png)

`quad`で定義されているのはリトルエンディアンで逆向きになったマシン語そのものだったらしい。かなりご丁寧にデコンパイルしたCコードまで付けてくれている。

というものの、デコンパイルされたCコードには見たことのない変数が多く定義されておりかなり意味不明なので、アセンブリから地道に読んでいくことにした。

同時に、意味が完全に不明だった解説もようやく理解した。この難読化された`quad`に書かれているアセンブリのことだったのだ。

### 1つめの`__asm__`の意味

改めて山D先生のコードを掲載する。

```c
__asm__(".quad 0xcfff48aef2fcffb1" : "=D"(d) : "D"(s), "a"(0));
```

ここまでの調べで`quad`にかかれている実態は以下のアセンブリであることがわかった。また、実行結果が`RDI`レジスタに格納され、それを`void* d`が受け取ることもわかった。

そしてこのコードは何かしらの関数であり、引数?として`RDI`に文字列のアドレス(`void* s`)を渡しており`RAX=0`で初期化していることもわかった。

更に、Ghidraのデコンパイルをなんとなく眺める限りでは、`\0`を探しているようなことが書かれている。

ここまで判明するのに2時間ほどかかった気がする。で、そのアセンブリの実態は以下である。

```asm
b1 ff           mov cl,0xff
fc              cld
f2 ae           repnz scas al,BYTE PTR es:[rdi]
48 ff cf        dec rdi
```

ということで、これを擬似コードに書き起こしてみる。

```c
// 以下はインラインアセンブリによる初期化
rdi=s // "D"(s)
al=0 // "a"(0)

ecx=256 // mov cl, 0xff
df=0 // cld

// repnz scas al, BYTE PTR es:[rdi]
while (ecx != 0){
  zf = (al == *(char *)rdi);
  rdi++ // dfが0なので左から右に読んでいく
  ecx--
  if (zfF) break;
}
rdi-- // dec rdi
```

実のところ、`f2 ae`の部分の理解が怪しい。
`while`と`ecx`のデクリメント、`zf`に応じたループの終了を担当しているのが`repne`で、
`scacb`が`al`との比較やrdiのインクリメント、`zf`の変更を行っているという認識である。

このあたりが最もよくわからず、理解に時間がかかった。最終的に先輩が以下の資料を見つけてくれたので解決できた。

[x86 \- REPNZ SCAS Assembly Instruction Specifics \- Stack Overflow](https://stackoverflow.com/questions/26783797/repnz-scas-assembly-instruction-specifics)

要約すると、`al`に入っている文字コードが見つかるまで`rdi`をインクリメントさせている。

今回の場合は`"a"(0)`により0が入っているので、ヌル文字を見つけていることになる。

この時点で`d`にはヌル文字のあるアドレスが格納されている。この後、文字列の末尾を示す`d`は出力対象の文字列の長さを取得するために利用されるのだが、長さにヌル文字は不要である。

したがって、ヌル文字分を除外し、正しい文字列長へ調整を行うのが最後の`dec rdi`である。

#### 余談1 `dec rdi`を削除してみる

この検証を確認するために、`dec rdi`を削除して出力の実験を行った。

![dec rdiを消してみる](no-dec-rdi.png)

`\0`まで出力されていることがわかる。

おそらく

> あと，NULLまでwriteしてたのも修正した。

と言っているのはこれ。

### 2つめの`__asm__`の意味

こちらのアセンブリ文はかなりすぐに解決できた。

```c
__asm__("syscall" :: "a"(1), "D"(1), "S"(s), "d"(d-s));
```

(Googlabilityの高い)`syscall`という明確なキーワードが非常に助かる。

アセンブリでシステムコールを呼び出す方法はかなりすぐに見つけることができる。

[Syscall Number for x86\-64 linux \(A\)](https://www.mztn.org/lxasm64/x86_x64_table.html)

`rax`にシステムコール番号、その後引数を順番に`rdi`,`rsi`,`rdx`に設定していく。

[Linuxカーネルに見る、システムコール番号と引数、システムコール・ラッパーとは：main\(\)関数の前には何があるのか（7）（1/2 ページ） \- ＠IT](https://atmarkit.itmedia.co.jp/ait/articles/1703/01/news172.html)

今回はターミナルに出力を行うので、`rax`に`write`のシステムコール番号`1`を指定(`"a"(a)`)。

続いて`rdi`ではファイルディスクリプタを指定。`"D"(1)`であるため、`/dev/fd/1`すなわち標準出力に対応している。
`rsi`にはバッファの指定を行う。今回の場合は`void* s`のアドレスの指定を行う。
`rdx`は出力する長さの指定を行う。`s`と`d`には文字列の先頭と末尾のアドレスが指定されているため、`d-s`で文字列長を取得できる。

以上の引数の指定によってシステムコールを発行し出力を行える。

### リトルエンディアンのありがたみ

Javaの仮想マシンはビッグエンディアンだとか、Armはどっちでもいけるだとか、色々話を聞きますが結局どういうときにどっちがどう嬉しいのかがわからない。

単にプロトコル(アーキテクチャ)の違いでしか無いんだろうか。

### `quad`で定義した数値が実行される理由

これ調べてもよくわからなくて山Dに聞きました。`quad`は単に64bitの数値を埋め込めるという理解で正しいらしい。

C言語の関数内において数値を埋め込んでいるために実行権限のあるメモリ内に展開され、実行できるという仕組みらしい。

この挙動はどこで説明されているのかもよくわからない。時間があるときに調べようと思う。

## 終わりに

基本的な命令しか知らなかった上に、知識として知っているだけで実際に書いたり読んだりといったことをしたことがなかったため非常に勉強になった。

理解するのにトータルで5時間ほどかかったが、最初から最後まで付き合ってくれた分類器先輩には感謝しかない。

そしてこれを数年前に書いており、色々と質問に答えてくれた山Dにも感謝。私はまだまだ弱い……
